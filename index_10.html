<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <meta charset="utf-8">
    <title>#ReframeClimate</title>
    <meta name="description" content="">
    <meta name="author" content="Magnum Foundation">
    <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/skeleton.css">
    <link rel="stylesheet" type="text/css" href="css/models.css">
    <link rel="stylesheet" href="css/style.css">
    <!-- Favicon STILL NEEDED
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <link rel="icon" type="image/png" href="images/favicon.png">
</head>

<body>
    <div id="blocker">
        <div id="instructions">
            <span style="font-size:40px">Click to play</span>
            <br /> ( ∧ ∨ = Move, MOUSE = Look around)
        </div>
    </div>
    <!-- landing section -->
    <div class="container">
        <section id="landing">
            <img id="dual-logo" src="css/images/magnumdysturb.png">
            <div class="centered-text">
                <h1>#ReframeClimate</h1>
                <p>For COP21, Magnum Foundation and #Dysturb partnered to curate 25 documentary photographs that #reframeclimate and paste them throughout the streets of Paris. Together, we’re amplifying the voices of those with eyes constantly on our world.</p>
                <!-- <span id="loading">Loading...</span> -->
                <a class="button" href="#">Step Into The Frame</a>
            </div>
        </section>
    </div>
    <!-- internal section -->
    <section id="internal">
        <div id="overlay">
            <div id="inner">
                <img class="logo" id="magnum-logo" src="css/images/magnumlogo.gif">
                <!-- make link and add real logo -->
                <img class="logo" id="dysturb-logo" src="css/images/dysturblogo.png">
                <!-- make link and add real logo -->
                <div id="nav-right">
                    <ul class="nav-element">
                        <li class="social" id="facebook"></li>
                        <li class="social" id="instagram"></li>
                        <li class="social" id="twitter"></li>
                    </ul>
                    <button id="embed" class="button nav-element" data-clipboard-text="<object data='http://www.rosalieyu.com/dysturb/test_3/index.html' width='800' height='500'><embed src='http://www.rosalieyu.com/dysturb/test_3/index.html' width='800' height='500'/></object>">Embed</button>
                    <!-- <div class="menu-btn nav-element"></div> -->
                </div>
                <div class="centered-text">
                    <!--                         <div id="instructions">Use your mouse or arrow keys to move around. Approach a pasted photo to hear the photographer tell the story behind their image and to watch the installation.</div> -->
                    <a class="button" href="#">Begin</a>
                </div>
            </div>
    </section>
    </div>
    <script src="js/Three.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/PointerLockControls.js"></script>
    <script src="js/SkyShader.js"></script>
    <script src="js/libs/dat.gui.min.js"></script>
    <script src="js/audioModule.js"></script>
    <!-- <script src="js/TrackballControls.js"></script> -->
    <script src="js/OBJLoader.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/libs/stats.min.js"></script>
    <script src="clipboard.js-master/dist/clipboard.min.js"></script>
    <script src="js/BinaryLoader.js"></script>
    <!-- <script src="js/DeviceOrientationControls.js"></script> -->
    <script>
    if (!Detector.webgl) Detector.addGetWebGLMessage();
    var camera, scene, renderer;
    var geometry, material, mesh;
    var controls;
    var MovingCube;
    var CameraCube;
    var blocker = document.getElementById('blocker');
    var instructions = document.getElementById('instructions');
    var objects = [];
    var raycaster;
    var container, stats;
    var cross;
    var loadingComplete = false;
    var isHit = false;
    var isHitFront = false;
    var isHitBack = false;
    var isHitLeft = false;
    var isHitRight = false;
    var rays;
    var rayForMovies;
    var sky, sunSphere;

    //audio
    var audioPaths = ["./audio/bendiksen1-aud.mp3", "./audio/sturco-aud.mp3", "./audio/ou-aud.mp3"];
    var audioList; // initialized later

    // test raycasting
    var mouse = new THREE.Vector2(), INTERSECTED;
    document.addEventListener( 'mousemove', onDocumentMouseMove, false );
    function onDocumentMouseMove(event) {
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    }

    //mobile
    var mouse_x;
    var mouse_y;
    var videoIsLoaded = false;
    var thisIsTouchDevice = false;
    var whichMobile = "";
    var noTouch = true;
    if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        console.log("I'm iOS!");
        whichMobile = "iOS_mobile";
    }
    if (/Android/i.test(navigator.userAgent)) {
        console.log("I'm Android!");
        whichMobile = "android_mobile";
    }
    if (isTouchDevice()) thisIsTouchDevice = true;
    if (whichMobile !== "") {
        blocker.style.display = 'none';
        instructions.style.display = 'none';
    }
    // if (whichMobile=="") {
    //     var clickDiv = document.createElement('div');
    //     clickDiv.id = "blocker";
    //     // ...
    //     document.getElementsByTagName("body")[0].appendChild(clickDiv);
    //     var ins = document.createElement('div');
    //     ins.id = "instructions";
    //     clickDiv.appendChild(ins);
    //     var span = document.createElement('span');
    //     // span.style = "font-size:40px";
    //     span.innerHTML = "Click to Play!"
    //     document.getElementById('instructions').appendChild(span);
    //     console.log("create div");
    // }
    function isTouchDevice() {
        return 'ontouchstart' in window || !!(navigator.msMaxTouchPoints);
    }
    //
    var lastTime0 = Date.now();
    var lastTime1 = Date.now();
    var lastTime2 = Date.now();
    var time0;
    var time1;
    var time2;
    var movieScreenArray = [];
    // custom global variables
    var videoImageContext = [];
    var videoTexture = [];
    var videoList = new Array();
    var hit0 = false;
    var hit1 = false;
    var hit2 = false;
    var mp4Source0 = document.createElement('source');
    mp4Source0.src = "videos/jonas_Bendiksen1-vid.mp4";
    var webmSource0 = document.createElement('source');
    webmSource0.src = "videos/Jonas_Bendiksen1.webm";
    videoList[0] = document.createElement('video');
    videoList[0].appendChild(webmSource0);
    videoList[0].appendChild(mp4Source0);
    //videoList[0].autoplay = true;
    videoList[0].load();
    var mp4Source1 = document.createElement('source');
    mp4Source1.src = "videos/Paolo_Pellegrin-vid.mp4";
    var webmSource1 = document.createElement('source');
    webmSource1.src = "videos/Paolo_Pellegrin.webm";
    videoList[1] = document.createElement('video');
    videoList[1].appendChild(webmSource1);
    videoList[1].appendChild(mp4Source1);
    //videoList[2].autoplay = true;
    videoList[1].load();
    var mp4Source2 = document.createElement('source');
    mp4Source2.src = "videos/Ed_Ou-vid.mp4";
    var webmSource2 = document.createElement('source');
    webmSource2.src = "videos/Ed_Ou.webm";
    videoList[2] = document.createElement('video');
    videoList[2].appendChild(webmSource2);
    videoList[2].appendChild(mp4Source2);
    //videoList[1].autoplay = true;
    videoList[2].load();
    //collidar
    var collidableMeshList = [];
    if (whichMobile == "") {
        // http://www.html5rocks.com/en/tutorials/pointerlock/intro/
        var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
        if (havePointerLock) {
            var element = document.body;
            var pointerlockchange = function(event) {
                if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
                    controlsEnabled = true;
                    controls.enabled = true;
                    blocker.style.display = 'none';
                } else {
                    controls.enabled = false;
                    blocker.style.display = '-webkit-box';
                    blocker.style.display = '-moz-box';
                    blocker.style.display = 'box';
                    instructions.style.display = '';
                }
            };
            var pointerlockerror = function(event) {
                instructions.style.display = '';
            };
            // Hook pointer lock state change events
            document.addEventListener('pointerlockchange', pointerlockchange, false);
            document.addEventListener('mozpointerlockchange', pointerlockchange, false);
            document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
            document.addEventListener('pointerlockerror', pointerlockerror, false);
            document.addEventListener('mozpointerlockerror', pointerlockerror, false);
            document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
            instructions.addEventListener('click', function(event) {
                instructions.style.display = 'none';
                // Ask the browser to lock the pointer
                element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                if (/Firefox/i.test(navigator.userAgent)) {
                    var fullscreenchange = function(event) {
                        if (document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element) {
                            document.removeEventListener('fullscreenchange', fullscreenchange);
                            document.removeEventListener('mozfullscreenchange', fullscreenchange);
                            element.requestPointerLock();
                        }
                    };
                    document.addEventListener('fullscreenchange', fullscreenchange, false);
                    document.addEventListener('mozfullscreenchange', fullscreenchange, false);
                    element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
                    element.requestFullscreen();
                } else {
                    element.requestPointerLock();
                }
            }, false);
        } else {
            instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
        }
    }
    var controlsEnabled = true;
    var moveForward = false;
    var moveBackward = false;
    var moveLeft = false;
    var moveRight = false;
    var canJump = false;
    var prevTime = performance.now();
    var velocity = new THREE.Vector3(0, 0, 0);
    //touch
    // window.history.replaceState(null, null, "http://www.rosalieyu.com/dysturb/test_3/index_5.html");
    //if (thisIsTouchDevice) 
    document.body.addEventListener("touchstart", handleStart, false);
    document.body.addEventListener("touchstart", get_mouse_coords, false);
    document.body.addEventListener("touchmove", handleMove, false);
    document.body.addEventListener("touchend", handleEnd, false);
    var videoNum = 1;

    function handleStart(evt) {
        evt.preventDefault();
        moveForward = true;
        // if (!videoIsLoaded) {
        //     videoList[1].load();
        //     videoIsLoaded = true;
        // }
        if (whichMobile == "android_mobile") {
            for (var i = 0; i < videoList.length; i++) {
                videoList[i].load();
                videoList[i].play();
                // videoList[i].pause();
            }
            noTouch = false;
            console.log("touch!");
        }
    }

    function get_mouse_coords(evt) {
        mouse_x = evt.pageX;
        mouse_y = evt.pageY;
    }

    function handleMove(evt) {
        evt.preventDefault();
        moveForward = false;
        moveBackward = false;
        var new_mouse_x = evt.pageX;
        if ((new_mouse_x - mouse_x) > 60) {
            moveLeft = true;
            moveRight = false;
        } else if ((new_mouse_x - mouse_x) < -60) {
            moveRight = true;
            moveLeft = false;
        }
        if (evt.scale < 1.0) {
            moveForward = false;
            moveBackward = true;
        } else if (evt.scale > 1.0) {
            moveBackward = false;
            moveForward = true;
        }
    }

    function handleEnd(evt) {
        evt.preventDefault();
        moveForward = false;
        moveBackward = false;
        moveLeft = false;
        moveRight = false;
    }

    function isTouchDevice() {
        return 'handleStart' in window || !!(navigator.msMaxTouchPoints);
    }

    init();
    animate();

    //clipboard
    var btn = document.getElementById('btn');
    var clipboard = new Clipboard(btn);
    clipboard.on('success', function(e) {
        console.log(e);
    });
    clipboard.on('error', function(e) {
        console.log(e);
    });

    function copyToClipboard(text) {
        window.prompt("Copy to clipboard: Ctrl+C, Enter", text);
    }

    function initSky() {

        // Add Sky Mesh
        sky = new THREE.Sky();
        scene.add(sky.mesh);

        // Add Sun Helper
        sunSphere = new THREE.Mesh(
            new THREE.SphereBufferGeometry(20000, 16, 8),
            new THREE.MeshBasicMaterial({
                color: 0xffffff
            })
        );
        sunSphere.position.y = -700000;
        sunSphere.visible = false;
        scene.add(sunSphere);

        /// GUI

        var effectController = {
            turbidity: 10,
            reileigh: 2,
            mieCoefficient: 0.005,
            mieDirectionalG: 0.8,
            luminance: 1,
            inclination: 0.49, // elevation / inclination
            azimuth: 0.25, // Facing front,
            sun: !true
        };

        var distance1 = 400;

        function guiChanged() {

            var uniforms = sky.uniforms;
            uniforms.turbidity.value = effectController.turbidity;
            uniforms.reileigh.value = effectController.reileigh;
            uniforms.luminance.value = effectController.luminance;
            uniforms.mieCoefficient.value = effectController.mieCoefficient;
            uniforms.mieDirectionalG.value = effectController.mieDirectionalG;

            var theta = Math.PI * (effectController.inclination - 0.5);
            var phi = 2 * Math.PI * (effectController.azimuth - 0.5);

            sunSphere.position.x = distance1 * Math.cos(phi);
            sunSphere.position.y = distance1 * Math.sin(phi) * Math.sin(theta);
            sunSphere.position.z = distance1 * Math.sin(phi) * Math.cos(theta);

            sunSphere.visible = effectController.sun;

            sky.uniforms.sunPosition.value.copy(sunSphere.position);

            renderer.render(scene, camera);
            //container = document.getElementById('internal');

        }

        var gui = new dat.GUI();

        gui.add(effectController, "turbidity", 1.0, 20.0, 0.1).onChange(guiChanged);
        gui.add(effectController, "reileigh", 0.0, 4, 0.001).onChange(guiChanged);
        gui.add(effectController, "mieCoefficient", 0.0, 0.1, 0.001).onChange(guiChanged);
        gui.add(effectController, "mieDirectionalG", 0.0, 1, 0.001).onChange(guiChanged);
        gui.add(effectController, "luminance", 0.0, 2).onChange(guiChanged);
        gui.add(effectController, "inclination", 0, 1, 0.0001).onChange(guiChanged);
        gui.add(effectController, "azimuth", 0, 1, 0.0001).onChange(guiChanged);
        gui.add(effectController, "sun").onChange(guiChanged);

        guiChanged();

    }

    var distance = 400000;

    // play audio + video, and pause the rest
    function mediaPlay(num) {
        var mediaLength = audioList.length;
        for (var i = 0; i < mediaLength; i++) {
            if (i == num) {
                if (!audioList[i].isPlaying) {
                    try {
                        audioList[i].play();
                    } catch (e) {
                        console.log(e)
                    }
                    videoList[i].play();
                }
            } else {
                try {
                    audioList[i].pause();
                } catch (e) {}
                videoList[i].pause();
            }
        }
    }


    function init() {

        //CUBE
        var cubeGeometry = new THREE.CubeGeometry(600, 500, 350);
        var wireMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            wireframe: true,
            transparent: true,
            opacity: 0
        });
        MovingCube = new THREE.Mesh(cubeGeometry, wireMaterial);
        MovingCube.position.set(0, -50, -600);
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
        cubeGeometry = new THREE.CubeGeometry(10, 10, 50);
        wireMaterial = new THREE.MeshBasicMaterial({
            wireframe: true,
            transparent: true,
            opacity: 0
        });
        CameraCube = new THREE.Mesh(cubeGeometry, wireMaterial);
        CameraCube.position.y = 7;
        // CameraCube.position.set(0, 200, 0);
        camera.add(MovingCube);
        camera.add(CameraCube);
        //camera.position.z = 500;
        //scene
        scene = new THREE.Scene();

        //sky helper
        var helper = new THREE.GridHelper(5000, 5000);
        helper.color1.setHex(0xffffff);
        helper.color2.setHex(0xffffff);
        scene.add(helper);

        //scene.fog = new THREE.Fog( 0xffffff, 0, 750 );
        var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.55);
        light.position.set(0.5, 1, 0.75);
        scene.add(light);
        var ambient = new THREE.AmbientLight(0x101030);
        scene.add(ambient);
        var directionalLight = new THREE.DirectionalLight(0xffeedd);
        directionalLight.position.set(0, 0, 1);
        scene.add(directionalLight);
        controls = new THREE.PointerLockControls(camera);
        scene.add(controls.getObject());

        var onKeyDown = function(event) {
            //console.log(event);
            //console.log('keydown! --> ' + event.keyCode);
            switch (event.keyCode) {
                case 'touchstart':
                case 38: // up
                case 87: // w
                    moveForward = true;
                    break;
                case 37: // left
                case 65: // a
                    moveLeft = true;
                    break;
                case 40: // down
                case 83: // s
                    moveBackward = true;
                    break;
                case 'touchmove':
                case 39: // right
                case 68: // d
                    moveRight = true;
                    break;
                case 32: // space
                    if (canJump === true) velocity.y += 350;
                    canJump = false;
                    break;
            }
        };
        // Set the rays : one vector for every potential direction
        rays = [
            new THREE.Vector3(0, 0, 1), // z  // backward
            new THREE.Vector3(1, 0, 1), // x, z // backward right
            new THREE.Vector3(1, 0, 0), // x    // right
            new THREE.Vector3(1, 0, -1), // x, -z // forward right
            new THREE.Vector3(0, 0, -1), // -z   // forward
            new THREE.Vector3(-1, 0, -1), // -x, -z // forward left
            new THREE.Vector3(-1, 0, 0), // -x  // left
            new THREE.Vector3(-1, 0, 1) // -z  // backward left
        ];
        var onKeyUp = function(event) {
            ///console.log('keyup! --> ' + event.keyCode);
            var currentKeyCode = event.keyCode;
            switch (currentKeyCode) {
                case 38: // up
                    moveForward = false;
                    break;
                case 87: // w
                    moveForward = false;
                    break;
                case 37: // left
                    moveLeft = false;
                    break;
                case 65: // a
                    moveLeft = false;
                    break;
                case 40: // down
                    moveBackward = false;
                    break;
                case 83: // s
                    moveBackward = false;
                    break;
                case 39: // right
                    moveRight = false;
                    break;
                case 68: // d
                    moveRight = false;
                    break;
            }
            // if(currentKeyCode==38){
            //  moveForward = false;
            // }
            // if else(currentKeyCode==87){
            //  moveForward = false;
            // }    
            // if else(currentKeyCode==37){
            //  moveLeft = false;
            // }                                        
        };
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);
        raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);
        rayForMovies = new THREE.Raycaster();
        //model Jason collider
        // new THREE.JSONLoader().load('./hiRes/cubeColliders.js', function(geometry) {
        //     var objectCollider = new THREE.Mesh(geometry);
        //     objectCollider.position.set(0, 0, 0);
        //     objectCollider.scale.set(2, 2, 2);
        //     //scene.add(objectCollider);
        //     collidableMeshList.push(objectCollider);
        // });
        // //model Jason
        new THREE.JSONLoader().load('hiRes/120915_15.js', function(geometry, materials) {
            var material = new THREE.MeshFaceMaterial(materials);
            for (var i = 0; i < materials.length; i++)
                materials[i].side = THREE.DoubleSide;

            var object = new THREE.Mesh(geometry, material);
            object.position.set(0, 0, 0);
            object.scale.set(2, 2, 2);
            scene.add(object);
            loadingComplete = true;
            collidableMeshList.push(object);
        });

        for (var i = 0; i < 2; i++) {
            var videoImage = document.createElement('canvas');
            videoImage.width = 350;
            videoImage.height = 169;
            container = document.getElementById('internal');
            //container.appendChild(renderer.domElement); //>>> >>> > 60 de8d03b968281e676bb8bab13eb1c9709f2217
            videoImageContext[i] = videoImage.getContext('2d');
            // background color if no video present
            videoImageContext[i].fillStyle = '#000000';
            videoImageContext[i].fillRect(0, 0, videoImage.width, videoImage.height);
            videoTexture[i] = new THREE.Texture(videoImage);
            videoTexture[i].minFilter = THREE.LinearFilter;
            videoTexture[i].magFilter = THREE.LinearFilter;
            var movieMaterial = new THREE.MeshBasicMaterial({
                map: videoTexture[i],
                overdraw: true,
                side: THREE.DoubleSide
            });
            // the geometry on which the movie will be displayed;
            //      movie image will be scaled to fit these dimensions.
            var movieGeometry = new THREE.PlaneGeometry(550, 265, 3, 3);
            movieScreenArray.push(new THREE.Mesh(movieGeometry, movieMaterial));
        }
        //screen [2]
        var videoImage1 = document.createElement('canvas');
        videoImage1.width = 350;
        videoImage1.height = 169;
        videoImageContext[2] = videoImage1.getContext('2d');
        // background color if no video present
        videoImageContext[2].fillStyle = '#000000';
        videoImageContext[2].fillRect(0, 0, videoImage1.width, videoImage1.height);
        videoTexture[2] = new THREE.Texture(videoImage1);
        videoTexture[2].minFilter = THREE.LinearFilter;
        videoTexture[2].magFilter = THREE.LinearFilter;
        var movieMaterial1 = new THREE.MeshBasicMaterial({
            map: videoTexture[2],
            overdraw: true,
            side: THREE.DoubleSide
        });
        new THREE.JSONLoader().load('hiRes/curvedPlaneVideoTexture_04.js', function(geometry) {
            movieScreenArray[2] = new THREE.Mesh(geometry, movieMaterial1);
            movieScreenArray[2].scale.set(2, 2, 2);
            scene.add(movieScreenArray[2]);
            // add audio to this mesh
            audioList.push( Audio3d.addAudioToMesh(audioPaths[2], movieScreenArray[2]) );
        });
        movieScreenArray[0].position.set(1530, 130, -5050.82);
        movieScreenArray[0].rotation.y = -0.94;
        movieScreenArray[1].position.set(-653, 50, -2212);
        movieScreenArray[1].rotation.y = 1.7;
        scene.add(movieScreenArray[0]);
        scene.add(movieScreenArray[1]);
        //push this screen to the collidibale list
        //collidableMeshList.push(movieScreenArray[i]);
        //position the screens and add them to the scene
        //camera.position.set(0,80,300);
        //camera.lookAt(movieScreenArray[0].position);
        //SKYBOX/FOG
        // var skyBoxGeometry = new THREE.CubeGeometry(10000, 10000, 10000);
        // var skyBoxMaterial = new THREE.MeshBasicMaterial({
        //     color: 0x330000,
        //     side: THREE.DoubleSide
        // });
        // var skyBox = new THREE.Mesh(skyBoxGeometry, skyBoxMaterial);
        // scene.add(skyBox);
        //scene.fog = new THREE.FogExp2(0x330000, 0.00025);
        // lights
        // light = new THREE.DirectionalLight(0xffffff);
        // light.position.set(1, 1, 1);
        // scene.add(light);
        // light = new THREE.DirectionalLight(0x002288);
        // light.position.set(-1, -1, -1);
        // scene.add(light);
        //spot light1              (hex, intensity, distance, angle, exponent, decay)
        light = new THREE.SpotLight(0xFFCC66, 1, 0, 0.1, 9, 0.1);
        light.position.set(-42.34, 17, 227);
        light.shadowCameraVisible = true;
        light.shadowDarkness = 0.95;
        // must enable shadow casting ability for the light
        light.castShadow = true;
        scene.add(light);
        light.target = MovingCube;
        //point light
        // light = new THREE.PointLight(0xff0000, 1, 100);
        // light.position.set(130, 70, -690);
        // scene.add(light);
        // light = new THREE.AmbientLight(0x404040);
        // scene.add(light);
        // light = new THREE.PointLight( 0xff0040, 1, 50 );
        // scene.add( light );
        // renderer
        renderer = new THREE.WebGLRenderer();
        //set background color
        renderer.setClearColor(0x00001a);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        container = document.getElementById('internal');
        container.appendChild(renderer.domElement);
        //FPS
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        stats.domElement.style.zIndex = 100;
        // container.appendChild( stats.domElement );
        //

        initSky();

        window.addEventListener('resize', onWindowResize, false);

        // time to load audio for the meshes we have so far
        audioList = Audio3d.initAudio(audioPaths, camera, movieScreenArray);
        render();

    }


    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        //controls.handleResize();
        render();
    }

    function animate() {
        requestAnimationFrame(animate);
        update();
        render();
        //controls.update();                
    }

    function update() {
        //collision
        // MovingCube.position.set(controls.position().x, controls.position().y - 50, controls.position().z - 300);
        //var originPoint = MovingCube.position.clone();
        //!
        MovingCube.updateMatrixWorld();
        CameraCube.updateMatrixWorld();
        for (var vertexIndex = 0; vertexIndex < CameraCube.geometry.vertices.length; vertexIndex++) {
            var localVertex = CameraCube.geometry.vertices[vertexIndex].clone();
            var globalVertex = localVertex.applyMatrix4(CameraCube.matrix);
            var directionVector = globalVertex.sub(CameraCube.position);

            //Raycaster( origin, direction, near, far )
            // origin — The origin vector where the ray casts from.
            // direction — The direction vector that gives direction to the ray. Should be normalized.
            // And the "RayCaster", able to test for intersections    
            // For each ray
            for (i = 0; i < rays.length; i += 1) {
                // We reset the raycaster to this direction
                var cubeWorldPos = new THREE.Vector3();
                cubeWorldPos.setFromMatrixPosition(CameraCube.matrixWorld);
                rayForMovies.set(cubeWorldPos, rays[i]);
                // Test if we intersect with any obstacle mesh
                var collisionResults = rayForMovies.intersectObjects(collidableMeshList);
                // And disable that direction if we do
                if (collisionResults.length > 0 && collisionResults[0].distance < 200) {
                    //console.log('we have hit!');
                    //isHit = true;
                    if (i == 0 ) {
                        isHitBack = true;
                        isHitFront = false;
                        isHitRight = false;
                        isHitLeft = false;
                        console.log("isHitBack " + isHitBack);
                    } else if (i == 4 ) {
                        isHitBack = false;
                        isHitFront = true;
                        isHitRight = false;
                        isHitLeft = false;
                        console.log("isHitFront " + isHitFront);
                    } else if ( i == 6 ) {
                        isHitBack = false;
                        isHitFront = false;
                        isHitRight = false;
                        isHitLeft = true;
                        console.log("isHitLeft " + isHitLeft);
                    } else if (i == 2 ) {
                        isHitBack = false;
                        isHitFront = false;
                        isHitRight = true;
                        isHitLeft = false;
                        console.log("isHitRight " + isHitRight);
                    }
                } else {
                    //isHit = false;
                    //console.log("isHit = false");
                }
                //movie collider
                for (var vertexIndex = 0; vertexIndex < MovingCube.geometry.vertices.length; vertexIndex++) {
                    var localVertex = MovingCube.geometry.vertices[vertexIndex].clone();
                    var globalVertex = localVertex.applyMatrix4(MovingCube.matrix);
                    var directionVector = globalVertex.sub(MovingCube.position);

                    //Raycaster( origin, direction, near, far )
                    // origin — The origin vector where the ray casts from.
                    // direction — The direction vector that gives direction to the ray. Should be normalized.
                    // And the "RayCaster", able to test for intersections   
                    // For each ray
                    // We reset the raycaster to this direction
                    // var cubeWorldPos = new THREE.Vector3();
                    // cubeWorldPos.setFromMatrixPosition(MovingCube.matrixWorld);
                    // rayForMovies.set(cubeWorldPos, ray[i]);

                    // set based on mouse and camera
                    rayForMovies.setFromCamera(mouse, camera);

                    var maxDist = directionVector.length();

                    // get an array of all the movies intersecting the rayForMovies
                    var intersectingMovies = rayForMovies.intersectObjects(movieScreenArray);

                    if (intersectingMovies.length > 0) {
                        // for each...
                        intersectingMovies.forEach(function(item) {
                            // make sure distance < maxDistance (directionVector.length)
                            if (item.distance < maxDist) {
                                // find index of the item.object (mesh) in movieScreenArray
                                var movieIndex = movieScreenArray.indexOf(item.object);
                                switch(movieIndex) {
                                    case 0:
                                        hit0 = true;
                                        mediaPlay(0);
                                        break;
                                    case 1:
                                        hit1 = true;
                                        mediaPlay(1);
                                        break;
                                    case 2:
                                        hit2 = true;
                                        mediaPlay(2);
                                        break;
                                    default:
                                        break;
                                }
                            }
                        });
                    }
                }
                if (whichMobile == "android_mobile" && noTouch == false) {
                    if (hit0 == true) {
                        mediaPlay(0);
                        // videoList[0].play();
                        // videoList[1].pause();
                        // videoList[2].pause();
                    }
                    if (hit1 == true) {
                        mediaPlay(1);
                        // videoList[1].play();
                        // videoList[0].pause();
                        // videoList[2].pause();
                    }
                    if (hit2 == true) {
                        mediaPlay(2);
                        // videoList[2].play();
                        // videoList[0].pause();
                        // videoList[1].pause();
                    }
                }
                if (controlsEnabled) {
                    raycaster.ray.origin.copy(controls.getObject().position);
                    // raycaster.ray.origin.copy( MovingCube.position );
                    raycaster.ray.origin.y -= 10;
                    var intersections = raycaster.intersectObjects(objects);
                    var isOnObject = intersections.length > 0;
                    var controlTime = performance.now();
                    var delta = (controlTime - prevTime) / 300;

                    velocity.x -= velocity.x * 10.0 * delta;
                    velocity.z -= velocity.z * 10.0 * delta;

                    //velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
                    //if moveforad == true, collision check == false
                    // if ( moveForward && isHitFront == false ) 
                    //   velocity.z -= 400.0 * delta;
                    // if ( moveBackward && isHitBack == false) 
                    //  velocity.z += 400.0 * delta;
                    // if ( moveLeft && isHitLeft == false) 
                    //  velocity.x -= 400.0 * delta;
                    // if ( moveRight && isHitRight == false) 
                    //  velocity.x += 400.0 * delta;
                    // if (!isHitFront && !isHitBack && !isHitRight && !isHitLeft) {
                    if (moveForward && !isHitFront) {
                        velocity.z -= 10.0 * delta;
                        isHitBack = false;
                    }
                    if (moveBackward && !isHitBack) {
                        velocity.z += 10.0 * delta;
                        isHitFront = false;
                    }
                    if (moveLeft && !isHitLeft) {
                        velocity.x -= 10.0 * delta;
                        isHitRight = false;
                    }
                    if (moveRight && !isHitRight) {
                        velocity.x += 10.0 * delta;
                        isHitLeft = false;
                    }
                    if (isHitFront) {
                        if (moveBackward || moveLeft || moveRight) {
                            isHitFront = false;
                        }
                    }
                    if (isHitBack) {
                        if (moveForward || moveLeft || moveRight) {
                            isHitBack = false;
                        }
                    }
                    if (isHitLeft) {
                        if (moveBackward || moveForward || moveRight) {
                            isHitLeft = false;
                        }
                    }
                    if (isHitRight) {
                        if (moveForward || moveLeft || moveBackward) {
                            isHitRight = false;
                        }
                    }
                    // }
                    // if collider is hit
                    // see what was hit... set that to be true
                    // if isHitFront
                    // --> the user moves left, and isHit is false, isHitFront is true
                    // --> the user moves right, and isHit is false, isHitFront is true
                    // --> the user moves back, and isHit is false, isHitFront is true
                    // if()
                    controls.getObject().translateX(velocity.x);
                    controls.getObject().translateY(velocity.y);
                    controls.getObject().translateZ(velocity.z);
                    //console.log(MovingCube.position);
                    if (controls.getObject().position.y < 10) {
                        velocity.y = 0;
                        controls.getObject().position.y = 10;
                        canJump = true;
                    }
                    prevTime = controlTime;
                }
                stats.update();
            }
        }
    }
    var framesPerSecond = 29;

    function render() {

        //console.log(isHit);
        if (videoList[0].readyState === videoList[0].HAVE_ENOUGH_DATA) {
            if (whichMobile == "iOS_mobile") {
                time0 = Date.now();
                var elapsed0 = (time0 - lastTime0) / 1000;
                // render
                // for (var i = 0; i < videoList.length; i++) {
                if (elapsed0 >= ((1000 / framesPerSecond) / 1000)) {
                    videoList[0].currentTime0 = videoList[0].currentTime0 + elapsed0;
                    videoImageContext[0].drawImage(videoList[0], 0, 0);
                    videoImageContext[0].drawImage(videoList[0], 0, 0);
                    if (videoTexture[0])
                        videoTexture[0].needsUpdate = true;
                    lastTime0 = time0;
                    // if we are at the end of the video stop
                    var currentTime0 = (Math.round(parseFloat(videoList[0].currentTime0) * 10000) / 10000);
                    var duration0 = (Math.round(parseFloat(videoList[0].duration0) * 10000) / 10000);
                    if (currentTime0 >= duration0) {
                        console.log('currentTime: ' + currentTime0 + ' duration: ' + videoList[0].duration0);
                        // restart
                        //  videoList[0].currentTime0 = 0;
                        // return;
                    }
                }
                time1 = Date.now();
                var elapsed1 = (time1 - lastTime1) / 1000;
                // render
                // for (var i = 0; i < videoList.length; i++) {
                if (elapsed1 >= ((1000 / framesPerSecond) / 1000)) {
                    videoList[1].currentTime1 = videoList[1].currentTime1 + elapsed1;
                    videoImageContext[1].drawImage(videoList[1], 0, 0);
                    videoImageContext[1].drawImage(videoList[1], 0, 0);
                    if (videoTexture[1])
                        videoTexture[1].needsUpdate = true;
                    lastTime1 = time1;
                    // if we are at the end of the video stop
                    var currentTime1 = (Math.round(parseFloat(videoList[1].currentTime1) * 10000) / 10000);
                    var duration1 = (Math.round(parseFloat(videoList[1].duration1) * 10000) / 10000);
                    if (currentTime1 >= duration1) {
                        console.log('currentTime: ' + currentTime1 + ' duration: ' + videoList[1].duration1);
                        // restart
                        //  videoList[1].currentTime1 = 0;
                        // return;
                    }
                }
                time2 = Date.now();
                var elapsed2 = (time2 - lastTime2) / 1000;
                // render
                // for (var i = 0; i < videoList.length; i++) {
                if (elapsed2 >= ((1000 / framesPerSecond) / 1000)) {
                    videoList[2].currentTime2 = videoList[2].currentTime2 + elapsed2;
                    videoImageContext[2].drawImage(videoList[2], 0, 0);
                    videoImageContext[2].drawImage(videoList[2], 0, 0);
                    if (videoTexture[2])
                        videoTexture[2].needsUpdate = true;
                    lastTime2 = time2;
                    // if we are at the end of the video stop
                    var currentTime2 = (Math.round(parseFloat(videoList[2].currentTime2) * 10000) / 10000);
                    var duration2 = (Math.round(parseFloat(videoList[2].duration2) * 10000) / 10000);
                    if (currentTime2 >= duration2) {
                        console.log('currentTime: ' + currentTime2 + ' duration: ' + videoList[2].duration2);
                        // restart
                        //  videoList[2].currentTime2 = 0;
                        // return;
                    }
                }
                // }
            } else {
                for (var i = 0; i < videoList.length; i++) {
                    // if (videoList[0].readyState === videoList[0].HAVE_ENOUGH_DATA) {
                    videoImageContext[i].drawImage(videoList[i], 0, 0);
                    if (videoTexture[i])
                        videoTexture[i].needsUpdate = true;
                }
            }
        }
        renderer.render(scene, camera);
    }
    </script>
</body>

</html>